" This file represents the minimal .vimrc needed to work with govim.
"
" We also include a number of suggested settings that we think the majority of
" users will like/prefer.

set nocompatible
set nobackup
set nowritebackup
set noswapfile

filetype off
filetype plugin on

set rtp+=$HOME/.vim/bundle/Vundle.vim/
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'

" general vim improvements
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-vinegar'
Plugin 'tpope/vim-abolish'
Plugin 'tpope/vim-characterize'
Plugin 'tpope/vim-speeddating'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-afterimage'
Plugin 'sjl/gundo.vim'

" DB
Plugin 'tpope/vim-dadbod'
Plugin 'kristijanhusak/vim-dadbod-ui'

" Languages
Plugin 'jaxbot/semantic-highlight.vim'

"" LSP
Plugin 'prabirshrestha/vim-lsp'
"Plugin 'mattn/vim-lsp-settings'

"" Go
Plugin 'govim/govim'

"" JSON
Plugin 'tpope/vim-jdaddy'

"" CUE
Plugin 'jjo/vim-cue'

"" PlantUML
Plugin 'aklt/plantuml-syntax'

" Git
Plugin 'tpope/vim-fugitive'
Plugin 'gregsexton/gitv'
Plugin 'nicwest/vim-git-appraise'
Plugin 'airblade/vim-gitgutter'
Plugin 'whiteinge/diffconflicts'

" colorscheme/themes
Plugin 'altercation/vim-colors-solarized'
"Plugin 'lifepillar/vim-solarized8'

" Web
Plugin 'yosssi/vim-gcss'
Plugin 'yosssi/vim-ace'

" productivity
Plugin 'wakatime/vim-wakatime'

" inputs
Plugin 'junegunn/vim-emoji'
Plugin 'junegunn/fzf'
Plugin 'junegunn/fzf.vim'

call vundle#end()
filetype plugin indent on

" start govim default
set mouse=a

" To get hover working in the terminal we need to set ttymouse. See
"
" :help ttymouse
"
" for the appropriate setting for your terminal. Note that despite the
" automated tests using xterm as the terminal, a setting of ttymouse=xterm
" does not work correctly beyond a certain column number (citation needed)
" hence we use ttymouse=sgr
set ttymouse=sgr

" Suggestion: By default, govim populates the quickfix window with diagnostics
" reported by gopls after a period of inactivity, the time period being
" defined by updatetime (help updatetime). Here we suggest a short updatetime
" time in order that govim/Vim are more responsive/IDE-like
set updatetime=500

" Suggestion: To make govim/Vim more responsive/IDE-like, we suggest a short
" balloondelay
set balloondelay=250

" Suggestion: Turn on the sign column so you can see error marks on lines
" where there are quickfix errors. Some users who already show line number
" might prefer to instead have the signs shown in the number column; in which
" case set signcolumn=number
set signcolumn=yes

" Suggestion: Turn on syntax highlighting for .go files. You might prefer to
" turn on syntax highlighting for all files, in which case
"
" syntax on
"
" will suffice, no autocmd required.
"autocmd! BufEnter,BufNewFile *.go syntax on
"autocmd! BufLeave *.go syntax off
syntax on

" Suggestion: turn on auto-indenting. If you want closing parentheses, braces
" etc to be added, https://github.com/jiangmiao/auto-pairs. In future we might
" include this by default in govim.
set autoindent
set smartindent
filetype indent off

" Suggestion: define sensible backspace behaviour. See :help backspace for
" more details
set backspace=2

" Suggestion: show info for completion candidates in a popup menu
if has("patch-8.1.1904")
  set completeopt+=popup
  set completepopup=align:menu,border:off,highlight:Pmenu
endif

" end govim default

" personal govim
call govim#config#Set("GoImportsLocalPrefix","private.git.instance.com")
call govim#config#Set("ExperimentalWorkspaceModule", 1)
call govim#config#Set("GoplsEnv",{"GOFLAGS": "-tags=acceptance,e2e"})
call govim#config#Set("ExperimentalProgressPopups", 1)
"call govim#config#Set("ExperimentalSemanticTokens", 1)

" general vim
"
"" netrw
""" tree
let g:netrw_liststyle=0
""" open the vertical window with 80%
let g:netrw_winsize=80

"" make the cursor not go till the end
set scrolloff=5

" nice git review with vertical split
set diffopt+=vertical

" solarized
let g:solarized_termcolors=16
set background=dark
colorscheme solarized
"set t_Co=256

" gutter
set number

" save options
"" don't ask to save buffer when switching with another one
set hidden
"" save shortcuts
nnoremap <C-S>      :<C-U>update<CR>
vnoremap <C-S>      :<C-U>update<CR>gv
inoremap <C-S>      <C-O>:update<CR>

" command completion
set wildmenu
set wildmode=list:longest,full

" search options
"" ignore case in search
set ignorecase
"" don't ignore case when you type search with some uppercase char
set smartcase
"" highlight search
set hls

" Highlights
"" use :autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
" before colorscheme maybe ?
highlight ExtraWhitespace ctermbg=red guibg=red

" Show trailing whitespace:
match ExtraWhitespace /\s\+$/
" Show trailing whitespace and spaces before a tab:
match ExtraWhitespace /\s\+$\| \+\ze\t/
" Show NBSP
match ExtraWhitespace /Â /

" add GOPATH/src for file find
set path+=~/go/src


" mappings

"" diff
noremap ,d :Gdiff<CR>

"" Go
noremap <Leader>R :GOVIMRename<CR>
noremap <Leader>c :GOVIMReferences<CR>
"noremap K :GOVIM<CR>
noremap K : <C-u>call GOVIMHover()<CR>

" GovimFZFSymbol is a user-defined function that can be called to start fzf in
" a mode whereby it uses govim's new child-parent capabilities to query the
" parent govim instance for gopls Symbol method results that then are used to
" drive fzf.
function GovimFZFSymbol(queryAddition)
  let l:expect_keys = join(keys(s:symbolActions), ',')
  let l:source = join(GOVIMParentCommand(), " ").' gopls Symbol -quickfix'
  let l:reload = l:source." {q}"
  call fzf#run(fzf#wrap({
        \ 'source': l:source,
        \ 'sink*': function('s:handleSymbol'),
        \ 'options': [
        \       '--with-nth', '2..',
        \       '--expect='.l:expect_keys,
        \       '--phony',
        \       '--bind', 'change:reload:'.l:reload
        \ ]}))
endfunction

" Map \s to start a symbol search
"
" Once you have found the symbol you want:
"
" * Enter will open that result in the current window
" * Ctrl-s will open that result in a split
" * Ctrl-v will open that result in a vertical split
" * Ctrl-t will open that result in a new tab
"
nmap <Leader>s :call GovimFZFSymbol('')<CR>

" s:symbolActions are the actions that, in addition to plain <Enter>,
" we want to be able to fire from fzf. Here we map them to the corresponding
" command in VimScript.
let s:symbolActions = {
  \ 'ctrl-t': 'tab split',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit',
  \ }

" With thanks and reference to github.com/junegunn/fzf.vim/issues/948 which
" inspired the following
function! s:handleSymbol(sym) abort
  " a:sym is a [2]string array where the first element is the
  " key pressed (or empty if simply Enter), and the second element
  " is the entry selected in fzf, i.e. the match.
  "
  " The match will be of the form:
  "
  "   $filename:$line:$col: $match
  "
  if len(a:sym) == 0
    return
  endif
  let l:cmd = get(s:symbolActions, a:sym[0], "")
  let l:match = a:sym[1]
  let l:parts = split(l:match, ":")
  execute 'silent' l:cmd
  execute 'buffer' bufnr(l:parts[0], 1)
  set buflisted
  call cursor(l:parts[1], l:parts[2])
  normal! zz
endfunction



"" reviews
noremap ,D :Gdiff origin/master<CR>
" keep the current buffer and close the diff view, switch it to the next
" buffer and reopen the diff with origin/master
noremap ,N :wincmd o<CR>:bnext<CR>:Gdiff origin/master<CR>:wincmd w<CR>
noremap ,P :wincmd o<CR>:bprev<CR>:Gdiff origin/master<CR>:wincmd w<CR>
" toggle line wrapping on all windows of the current tab
noremap ,w :windo set wrap!<CR>

" vim-lsp

"function! s:on_lsp_buffer_enabled() abort
"    setlocal omnifunc=lsp#complete
"    setlocal signcolumn=yes
"    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
"    nmap <buffer> gd <plug>(lsp-definition)
"    nmap <buffer> gs <plug>(lsp-document-symbol-search)
"    nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
"    nmap <buffer> ,c <plug>(lsp-references)
"    nmap <buffer> gi <plug>(lsp-implementation)
"    nmap <buffer> ,t <plug>(lsp-type-definition)
"    nmap <buffer> <leader>rn <plug>(lsp-rename)
"    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
"    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
"    nmap <buffer> K <plug>(lsp-hover)
"    inoremap <buffer> <expr><c-f> lsp#scroll(+4)
"    inoremap <buffer> <expr><c-d> lsp#scroll(-4)
"
"    let g:lsp_format_sync_timeout = 1000
"    "autocmd! BufWritePre *.rs,*.go call execute('LspDocumentFormatSync')
"
"    " refer to doc to add more commands
"endfunction
"
"augroup lsp_install
"    au!
"    " call s:on_lsp_buffer_enabled only for languages that has the server registered.
"    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
"augroup END

" CUE
"" syntax

autocmd BufEnter,BufNewFile,BufRead *.cue setf cue
autocmd FileType cue setlocal syntax=cue


autocmd! BufEnter,BufNewFile *.cue syntax on
"autocmd! BufLeave *.cue syntax off


" CUE LSP
if executable('daggerlsp')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'daggerlsp',
        \ 'cmd': {server_info->['daggerlsp']},
        \ 'allowlist': ['cue'],
        \ })
endif

function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> gs <plug>(lsp-document-symbol-search)
    nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
    nmap <buffer> gr <plug>(lsp-references)
    nmap <buffer> gi <plug>(lsp-implementation)
    "nmap <buffer> gt <plug>(lsp-type-definition)
    nmap <buffer> <Leader>rn <plug>(lsp-rename)
    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
    nmap <buffer> K <plug>(lsp-hover)

    let g:lsp_format_sync_timeout = 1000
    autocmd! BufWritePre *.cue call execute('LspDocumentFormatSync')

    " refer to doc to add more commands
endfunction

let g:lsp_log_verbose = 1
let g:lsp_log_file = expand('/tmp/vim-lsp.log')

let g:lsp_experimental_workspace_folders = get(g:, 'lsp_experimental_workspace_folders', 1)

augroup lsp_install
    au!
    " call s:on_lsp_buffer_enabled only for languages that has the server registered.
    autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END
